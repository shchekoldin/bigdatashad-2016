# Домашнее задание 2

С расширением аудитории Zwitter, с развитием функционала социальной сети Zwitter, расширились требования и пожелания 
основателей стартапа. Теперь основатели-стартапщики хотят получать заранее вычисленную информацию о конкретных 
пользователях социальной сети, при этом, необходимое требование, чтобы запросы выполнялись максмально быстро.
 
## Что надо делать?

Во втором домашнем задании вам необходимо помочь основателями решить следующие задачи:
 
  * настроить ежедневный расчет метрик для всех пользователей социальной сети по уже собираемым логам в HDFS,
  * настроить сохранение расcчитанных метрик в таблицы HBase,
  * предоставить доступ к данным, хранящимся в HBase, через HTTP API.

Ниже вы можете найти более подробную информацию по следующим вопросам:

  * [Исходные данные](#Исходные-данные)
  * [Рассчитываемые метрики](#Рассчитываемые-метрики)
  * [Требования](#Требования)
  * [Критерии сдачи задания](#Критерии-сдачи-задания)
  * [Процесс сдачи задания](#Процесс-сдачи-задания)
  * [Спецификация HTTP API](#Спецификация-http-api)
  * [Дополнительные комментарии](#Дополнительные-комментарии)


## Исходные данные

В этом задании используются те же исходные данные, что и в первом домашнем задании: логи доступа к веб-серверу.

Из каждой записи в логе можно выделить **пользователя** и **посещенный профиль**: пользователь определяется IP-адресом, а посещенный профиль -- идентификатором, закодированном в URI запроса в виде `idNNNNN`.

К примеру, по записи

```
195.206.123.39 - - [24/Sep/2016:12:32:53 +0400] "GET /id18222 HTTP/1.1" 200 10703 "http://bing.com/" "Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/37.0.2062.94 Safari/537.36"
```

Можно сказать, что пользователь **195.206.123.39** посетил профиль **id18222**.

Также в данном задании вам будут важны лайки. Иногда некоторые пользователи ставят лайк профилю. В логах это соответствует хиту с параметром `like=1`, например

```
195.206.123.39 - - [24/Sep/2016:12:32:53 +0400] "GET /id18222?like=1 HTTP/1.1" 200 10703 "http://bing.com/" "Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/37.0.2062.94 Safari/537.36"
```

По данному хиту можно сказать, что пользователь **195.206.123.39** полайкал профиль **id18222**.

Как и в первом домашнии задании, для расчета целевых метрик вам стоит рассматривать только успешные (HTTP-код 200)
запросы к веб-сайту. Неуспешные запросы стоит игнорировать.

## Рассчитываемые метрики

Вам необходимо посчитать набор метрик для каждого пользователя социальной сети, для каждого профиля социальной сети,
а также перекрестную метрику по пользователям и профилям.

Метрики по профилям:

 * `profile_hits(profile, day) -> [(hour, count)]` -- суммарное количество просмотров определенного профиля всеми пользователями веб-сайта (распределение по часам);
 * `profile_users(profile, day) -> [(hour, count)]` -- суммарное количество уникальных пользователей, просматривавших данный профиль (распределение по часам).

Перекрестные метрики:

 * `user_most_visited_profiles(user, day) -> [profile]` -- множество профилей, просмотренных данным пользователем, в порядке убывания количества просмотров (при совпадении количества просмотров упорядочить профили лексикографически; метрика дневная).

 * `profile_last_three_liked_users(profile, day) -> [user]` -- последние три пользователя за пять последних дней, полайкавшие данный профиль, в порядке убывания времени посещения (первым в ответе самый последний полайкавший пользователь; дни считаются включительно, то есть при запросе за день X должны быть возвращены пользователи, которые полайкали в дни X, X-1, X-2, X-3, X-4).

## Требования

Ваше решение должно удовлетворять следующим требованиям:

  * вычисленные метрики должны располагаться в таблицах вида `bigdatashad_USER_TABLENAME`, где `USER` -- ваш логин, `TABLENAME` -- выбранное вами имя таблицы;
  * построенные таблицы не должны содержать более 500 стоблцов;
  * вычисление метрик для выполнения запросов должно происходить в процессе выполнения MR-задач
    (если вы пишете на Python, то можете использовать библиотеку HappyBase; если вы пишете на Java -- то нативную библиотеку HBase).
  * вычисленные данные должны быть готовы к 9 утра следующего дня (к примеру, результаты за 25.10
    должны быть готовы к 09:00 26.10); готовность вычисленных данных определяется возможностью выполнения запросов через HTTP API;
  * время ответа HTTP API не должно превышать 5 секунд;
  * ваш процесс расчета и обновления данных в HBase должен стабильно работать начиная с момента сдачи задания
    и до окончания курса, при этом ваше решение _не должно_ терять просчитанные данные за
    прошедшие дни (в том числе и после удаления исходных данных из HDFS).

## Критерии сдачи задания

За данное домашнее задание возможно заработать 10 попугаев.

  * за вычисленную метрику `profile_hits` выдается *один* (1) попугай;
  * за вычисленную метрику `profile_users` выдается *два* (2) попугая;
  * за вычисленную метрику `user_most_visited_profiles` выдается *три* (3) попугая;
  * за вычисленную метрику `profile_last_three_liked_users` выдается *четыре* (4) попугая;

До 16.11 необходимо реализовать вычисление метрик и зарегистрировать ваше решение в системе.

Если в течении подряд идущих *семи* (7) дней в период *с 16.11 до 20.12* ваш HTTP API не выдает вычисленные значения метрик / выдает неверные результаты, тогда из вашего результата будет вычтен один попугай (за каждые неработающие семь дней будет вычтено по одному попугаю).

## Процесс сдачи задания

Для самопроверки и сдачи вашего решения вам необходимо будет использовать веб-интерфейс Zwitter,
доступный на порту `8888` машины `hadoop2-00.yandex.ru` (NB: для доступа к веб-интерфейсу
вам необходимо пробросить `8888`-й порт на локальную машину, аналогично веб-интерфейсу Hadoop).

Для самопроверки вы можете использовать страницу по адресу `http://hadoop2-00.yandex.ru:8888/ysda/hw2`, где
вы можете указать порт, на котором работает ваше HTTP API, и диапазон дат.
При нажатии на кнопку "Query" будет выполнен запрос к вашему решению, проверена корректность ответа
(структура ответа и типы возвращаемых значений), и произведена отрисовка ответа.

Используя данный интерфейс вы можете проверить, что ваше решение корректно интегрируется в систему.

## Спецификация HTTP API

Ваше решение должно уметь отвечать на множество запросов типа `GET` по URI `/api/hw2/XXX`,
соответствующие вычисляемым метрикам. Если вы умеете вычислять запрашиваемую метрику,
то ваше решение должно отвечать с HTTP-кодом 200; в качестве ответа должен быть JSON-документ
с указанной в описании запроса структурой. Если вы не умеете вычислять запрашиваемую метрику,
то ваше решение должно отвечать с HTTP-кодом 404.

### `/api/hw2/profile_hits`

Параметры запроса:

  * `start_date` -- начальная дата в формате `YYYY-MM-DD` (включительно),
  * `end_date` -- конечная дата в формате `YYYY-MM-DD` (включительно),
  * `profile_id` -- идентификатор профиля в формате `idNNNNN`.

Формат ответа:

  * Ключами JSON-документа ответа являются даты в формате `YYYY-MM-DD`; значением по ключу является массив из 24 чисел, соответствующих метрике в каждый час указанной даты (часы отсчитываются с полуночи; 1-й элемент -- 00:00, ..., 24-й элемент -- 23:00).
  * Если у вас нет значений за какие-либо дни, то опустите ключ из ответа.

Пример запроса:

```
GET /api/hw2/profile_hits?start_date=2016-10-01&end_date=2016-10-02&profile_id=id10001
```

Пример ответа:

```json
{
  "2016-10-01": [10, 14, 9, 1, 0, 0, 0, ..., 4],
  "2016-10-02": [11, 18, 3, 1, 0, 0, 0, ..., 8]
}
```

### `/api/hw2/profile_users`

Параметры запроса:

  * `start_date` -- начальная дата в формате `YYYY-MM-DD` (включительно),
  * `end_date` -- конечная дата в формате `YYYY-MM-DD` (включительно),
  * `profile_id` -- идентификатор профиля в формате `idNNNNN`.

Формат ответа:

  * Ключами JSON-документа ответа являются даты в формате `YYYY-MM-DD`; значением по ключу является массив из 24 чисел, соответствующих метрике в каждый час указанной даты (часы отсчитываются с полуночи; 1-й элемент -- 00:00, ..., 24-й элемент -- 23:00).
  * Если у вас нет значений за какие-либо дни, то опустите ключ из ответа.

Пример запроса:

```
GET /api/hw2/profile_users?start_date=2016-10-01&end_date=2016-10-05&profile_id=id10001
```

Пример ответа:

```json
{
  "2016-10-01": [5, 7, 5, 1, 0, 0, 0, ..., 2],
  "2016-10-02": [6, 9, 1, 1, 0, 0, 0, ..., 3]
}
```

### `/api/hw2/user_most_visited_profiles`

Параметры запроса:

  * `date` -- дата в формате `YYYY-MM-DD`,
  * `user_ip` -- IP-адрес пользователя в формате `A.B.C.D`.

Формат ответа:

  * Ответом является JSON-документ с единственным ключем -- `profiles`.
  * Значением `profiles` является массив, кодирующий упорядоченный набор профилей.
    Каждый профиль кодируется как `idNNNNN`.
  * Если пользователь не заходил на сайт в указанную дату, то верните в качестве ответа пустой список.
  * Если вы по каким-либо причинам не можете обслужить запрос, то ответьте 500-й ошибкой.

Пример запроса:

```
GET /api/hw2/user_most_visited_profiles?date=2016-10-01&user_ip=81.221.37.3
```

Пример ответа:

```json
{
  "profiles": ["id10001", "id10002", "id10003"]
}
```

Пример пустого ответа:

```json
{
  "profiles": []
}
```

### `/api/hw2/profile_last_three_liked_users`

Параметры запроса:

  * `date` -- дата в формате `YYYY-MM-DD`,
  * `profile_id` -- идентификатор профиля в формате `idNNNNN`.

Формат ответа:

  * Ответом является JSON-документ с единственным ключем -- `users`.
  * Значением `users` является массив, кодирующий упорядоченный набор пользователей.
    Каждый профиль кодируется как `A.B.C.D`.
  * Если у профиля не было лайков в запрашиваемый период, то верните в качестве ответа пустой список.
  * Если вы по каким-либо причинам не можете обслужить запрос, то ответьте 500-й ошибкой.

Пример запроса:

```
GET /api/hw2/profile_last_three_liked_users?date=2016-10-01&profile_id=id10001
```

Пример ответа:

```json
{
  "users" : ["81.221.37.3", "81.221.37.4", "81.221.37.5"]
}
```

## Дополнительные комментарии

  * Продумайте количество и схему таблиц HBase, которые вы планируете использовать. В этом вам могут помочь материалы [HBaseCon 2012 | HBase Schema Design](http://www.cloudera.com/content/www/en-us/resources/hbasecon/video-hbasecon-2012-hbasecon-2012.html), а также [Introduction to HBase Schema Design](http://0b4af6cdc2f0c5998459-c0245c5c937c5dedcca3f1764ecc9b2f.r43.cf2.rackcdn.com/9353-login1210_khurana.pdf).
